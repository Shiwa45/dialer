"""
Agent Views (Simple Dashboard) - REBUILT WebRTC Integration

Changes:
- REMOVED separate webrtc_dashboard.html routing — ALL agents use simple_dashboard.html
- The RetroPhone component in simple_dashboard.html handles BOTH modes:
  * WebRTC-enabled: JsSIP registers in-browser, phone works via WebRTC
  * Non-WebRTC: phone shows softphone registration status, calls via Asterisk
- Fixed duplicate return statement
- Proper webrtc_config passed for RetroPhoneController consumption
"""

import json
import logging
from datetime import timedelta

from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_POST, require_http_methods
from django.utils import timezone
from django.db.models import Q, Sum
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync

from agents.decorators import agent_required
from agents.models import AgentDialerSession, AgentCallbackTask
from agents.telephony_service import AgentTelephonyService
from calls.models import CallLog
from campaigns.models import Campaign, Disposition, OutboundQueue
from leads.models import Lead
from users.models import AgentStatus
from telephony.models import Phone, AsteriskServer
from telephony.services import AsteriskService

logger = logging.getLogger(__name__)


def _build_webrtc_config(phone):
    """
    Build WebRTC config dict that the RetroPhoneController expects.
    
    RetroPhoneController._hasValidWebRTCConfig() checks for:
      cfg.username || cfg.extension  AND  cfg.password  AND  cfg.server
    
    RetroPhoneController._initWebRTC() reads:
      cfg.protocol, cfg.port, cfg.server  → builds wss://server:port/ws
      cfg.username || cfg.extension       → SIP URI user part
      cfg.from_domain || cfg.server       → SIP URI domain
      cfg.password                        → SIP auth
      cfg.display_name                    → display name
      cfg.ice_servers                     → ICE config
    """
    if not phone or not phone.asterisk_server:
        return {}

    server = phone.asterisk_server
    return {
        'success': True,
        'extension': phone.extension,
        'username': phone.extension,
        'password': getattr(phone, 'sip_password', None) or phone.secret,
        'server': server.server_ip,
        'from_domain': server.server_ip,
        'protocol': 'wss',
        'port': 8089,
        'display_name': phone.name or phone.extension,
        'ice_servers': [
            {'urls': phone.ice_host or 'stun:stun.l.google.com:19302'}
        ],
    }


def _get_dashboard_context(request, agent, agent_status, phone):
    """Helper to build consistent dashboard context"""
    from campaigns.models import Campaign, Disposition
    from agents.models import AgentCallbackTask
    from agents.telephony_service import AgentTelephonyService

    # Get assigned campaigns
    assigned_campaigns = Campaign.objects.filter(
        assigned_users=agent,
        status='active'
    )

    # Get current campaign
    current_campaign = agent_status.current_campaign
    if not current_campaign and assigned_campaigns.exists():
        current_campaign = assigned_campaigns.first()

    # Get phone info
    phone_info = {
        'extension': phone.extension if phone else None,
        'is_active': phone.is_active if phone else False,
        'webrtc_enabled': getattr(phone, 'webrtc_enabled', False) if phone else False,
        'registered': False
    }

    if phone:
        telephony_service = AgentTelephonyService(agent)
        try:
            phone_info['registered'] = telephony_service.is_extension_registered()
        except Exception as e:
            logger.warning(f"Could not check registration for {agent.username}: {e}")

    # Get today's stats
    today = timezone.now().date()
    today_calls = CallLog.objects.filter(agent=agent, start_time__date=today)

    today_stats = {
        'total_calls': today_calls.count(),
        'answered_calls': today_calls.filter(call_status='answered').count(),
        'talk_time': today_calls.aggregate(Sum('talk_duration'))['talk_duration__sum'] or 0,
    }

    # Pending callbacks
    pending_callbacks = AgentCallbackTask.objects.filter(
        agent=agent,
        status__in=['pending', 'scheduled'],
        scheduled_time__lte=timezone.now() + timedelta(hours=2)
    ).order_by('scheduled_time')[:5]

    # Available dispositions for current campaign
    available_dispositions = []
    if current_campaign:
        # Get dispositions linked to this campaign via CampaignDisposition
        from campaigns.models import CampaignDisposition
        campaign_dispositions = CampaignDisposition.objects.filter(
            campaign=current_campaign, is_active=True
        ).select_related('disposition').order_by('sort_order')
        
        available_dispositions = [
            {
                'id': cd.disposition.id,
                'name': cd.disposition.name,
                'category': cd.disposition.category,
                'is_sale': cd.disposition.is_sale,
                'is_callback': cd.disposition.requires_callback,
            }
            for cd in campaign_dispositions
        ]

    # Build WebRTC config for the RetroPhone
    # This gets injected into the page as JSON via json_script filter
    webrtc_config = {}
    if phone and phone.webrtc_enabled:
        webrtc_config = _build_webrtc_config(phone)

    context = {
        'user': agent,
        'agent': agent,
        'agent_status': agent_status,
        'assigned_campaigns': assigned_campaigns,
        'current_campaign': current_campaign,
        'today_stats': today_stats,
        'pending_callbacks': pending_callbacks,
        'available_dispositions': available_dispositions,
        'phone_info': phone_info,
        'webrtc_config': webrtc_config,

        # URLs for JS
        'call_status_url': '/agents/api/call-status/',
        'lead_info_url': '/agents/api/lead-info/',
        'disposition_url': '/agents/api/set-disposition/',
        'manual_dial_url': '/agents/api/manual-dial/',
        'hangup_url': '/agents/api/hangup/',
        'transfer_call_url': '/agents/api/transfer/',
    }

    return context


@login_required
@agent_required
def simple_dashboard(request):
    """
    Main agent dashboard view — UNIFIED for both WebRTC and softphone agents.
    
    The RetroPhone component in simple_dashboard.html handles both modes:
    - WebRTC enabled: initializes JsSIP UA, registers in browser
    - WebRTC disabled: shows softphone status, calls route via Asterisk
    """
    agent = request.user
    agent_status, _ = AgentStatus.objects.get_or_create(user=agent)
    phone = Phone.objects.filter(user=agent, is_active=True).first()

    # If no direct phone assignment, try by profile extension
    if not phone:
        try:
            ext = (agent.profile.extension or '').strip()
            if ext:
                phone = Phone.objects.filter(extension=ext, is_active=True).first()
        except Exception:
            pass

    context = _get_dashboard_context(request, agent, agent_status, phone)

    return render(request, 'agents/simple_dashboard.html', context)


@login_required
@agent_required
@require_POST
def update_status(request):
    """Update agent status"""
    agent = request.user
    new_status = request.POST.get('status', '').strip().lower()

    if not new_status:
        return JsonResponse({
            'success': False,
            'error': 'Status is required'
        })

    status_map = {
        'available': 'available',
        'ready': 'available',
        'break': 'break',
        'lunch': 'lunch',
        'meeting': 'meeting',
        'training': 'training',
        'offline': 'offline',
        'busy': 'busy',
        'wrapup': 'wrapup'
    }
    mapped_status = status_map.get(new_status, new_status)

    try:
        agent_status, _ = AgentStatus.objects.get_or_create(user=agent)
        agent_status.set_status(mapped_status)

        return JsonResponse({
            'success': True,
            'status': mapped_status,
            'display': agent_status.get_status_display()
        })
    except Exception as e:
        logger.error(f"Error updating status for {agent.username}: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Failed to update status'
        })


@login_required
@agent_required
@require_POST
def set_disposition(request):
    """Set call disposition"""
    agent = request.user
    call_id = request.POST.get('call_id')
    disposition_id = request.POST.get('disposition_id') or request.POST.get('disposition')
    notes = request.POST.get('notes', '')

    if not call_id:
        return JsonResponse({'success': False, 'error': 'Call ID is required'})
    if not disposition_id:
        return JsonResponse({'success': False, 'error': 'Disposition is required'})

    try:
        call_log = CallLog.objects.filter(id=int(call_id), agent=agent).first()
        if not call_log:
            return JsonResponse({'success': False, 'error': 'Call not found'})

        # Set disposition
        try:
            disposition = Disposition.objects.get(id=int(disposition_id))
            call_log.disposition = disposition.name
            call_log.disposition_id_fk = disposition
        except (Disposition.DoesNotExist, ValueError):
            call_log.disposition = str(disposition_id)

        call_log.agent_notes = notes
        call_log.save()

        # Update lead status based on disposition
        if call_log.lead:
            lead = call_log.lead
            if hasattr(disposition, 'lead_status_action') and disposition.lead_status_action:
                lead.status = disposition.lead_status_action
            lead.last_call_time = timezone.now()
            lead.save(update_fields=['status', 'last_call_time'])

        # Clear agent's current call
        agent_status = getattr(agent, 'agent_status', None)
        if agent_status:
            agent_status.current_call_id = None
            agent_status.set_status('available')

        # Broadcast call_cleared event (Phase 1.2 fix)
        try:
            channel_layer = get_channel_layer()
            async_to_sync(channel_layer.group_send)(
                f'agent_{agent.id}',
                {
                    'type': 'call_cleared',
                    'call_id': call_id,
                }
            )
        except Exception as ws_err:
            logger.warning(f"Failed to broadcast call_cleared: {ws_err}")

        return JsonResponse({
            'success': True,
            'message': 'Disposition saved successfully'
        })

    except Exception as e:
        logger.error(f"Error setting disposition: {e}")
        return JsonResponse({'success': False, 'error': 'Failed to save disposition'})


@login_required
@agent_required
@require_POST
def hangup_call(request):
    """Hang up current call"""
    agent = request.user
    call_id = request.POST.get('call_id')

    try:
        # Force hangup via Asterisk (Phase 1.3 fix)
        telephony_service = AgentTelephonyService(agent)
        if telephony_service.agent_phone and telephony_service.asterisk_server:
            try:
                asterisk_service = AsteriskService(telephony_service.asterisk_server)
                asterisk_service.hangup_channel(telephony_service.agent_phone.extension)
            except Exception as hangup_err:
                logger.warning(f"Asterisk hangup failed: {hangup_err}")

        # Update call log
        if call_id:
            try:
                call_log = CallLog.objects.filter(id=int(call_id), agent=agent).first()
                if call_log and call_log.call_status not in ('completed', 'failed'):
                    call_log.call_status = 'completed'
                    call_log.end_time = timezone.now()
                    if call_log.answer_time:
                        call_log.talk_duration = int(
                            (call_log.end_time - call_log.answer_time).total_seconds()
                        )
                    call_log.save()
            except (ValueError, TypeError):
                pass

        # Clear agent state
        agent_status = getattr(agent, 'agent_status', None)
        if agent_status:
            agent_status.current_call_id = None
            agent_status.save(update_fields=['current_call_id'])

        return JsonResponse({'success': True})

    except Exception as e:
        logger.error(f"Error hanging up call: {e}")
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
@agent_required
@require_http_methods(["GET"])
def get_lead_info(request):
    """Get lead information for current call"""
    agent = request.user
    lead_id = request.GET.get('lead_id')
    call_id = request.GET.get('call_id')

    try:
        lead = None
        if lead_id:
            lead = Lead.objects.filter(id=int(lead_id)).first()
        elif call_id:
            call_log = CallLog.objects.filter(id=int(call_id)).first()
            if call_log:
                lead = call_log.lead

        if not lead:
            return JsonResponse({'success': False, 'error': 'Lead not found'})

        # Get call history for this lead
        call_history = CallLog.objects.filter(lead=lead).order_by('-start_time')[:10]

        return JsonResponse({
            'success': True,
            'lead': {
                'id': lead.id,
                'first_name': lead.first_name,
                'last_name': lead.last_name,
                'phone_number': lead.phone_number,
                'email': getattr(lead, 'email', ''),
                'company': getattr(lead, 'company', ''),
                'city': getattr(lead, 'city', ''),
                'state': getattr(lead, 'state', ''),
                'status': lead.status,
                'notes': getattr(lead, 'notes', ''),
            },
            'call_history': [
                {
                    'id': c.id,
                    'date': c.start_time.strftime('%Y-%m-%d %H:%M'),
                    'status': c.call_status,
                    'duration': c.talk_duration or 0,
                    'disposition': c.disposition or '',
                }
                for c in call_history
            ]
        })

    except Exception as e:
        logger.error(f"Error getting lead info: {e}")
        return JsonResponse({'success': False, 'error': 'Failed to retrieve lead information'})


@login_required
@agent_required
@require_http_methods(["GET"])
def get_call_status(request):
    """Get current call status for agent"""
    agent = request.user

    try:
        agent_status = getattr(agent, 'agent_status', None)

        current_call = None
        if agent_status and agent_status.current_call_id:
            try:
                call_id = int(agent_status.current_call_id)
                call_log = CallLog.objects.filter(id=call_id).first()
                if call_log:
                    duration = 0
                    if call_log.answer_time:
                        duration = int((timezone.now() - call_log.answer_time).total_seconds())

                    current_call = {
                        'id': call_log.id,
                        'number': call_log.called_number,
                        'status': call_log.call_status,
                        'duration': duration,
                        'lead_id': call_log.lead_id
                    }
            except (TypeError, ValueError):
                pass

        return JsonResponse({
            'success': True,
            'status': agent_status.status if agent_status else 'offline',
            'current_call': current_call
        })

    except Exception as e:
        logger.error(f"Error getting call status: {e}")
        return JsonResponse({'success': False, 'error': 'Failed to get call status'})


@login_required
@agent_required
@require_http_methods(["GET"])
def get_webrtc_config(request):
    """
    Get WebRTC configuration for agent's phone.
    Called by the JS dashboard on page load.
    """
    agent = request.user

    try:
        phone = Phone.objects.filter(user=agent, is_active=True).first()

        if not phone:
            # Try by profile extension
            try:
                ext = (agent.profile.extension or '').strip()
                if ext:
                    phone = Phone.objects.filter(extension=ext, is_active=True).first()
            except Exception:
                pass

        if not phone or not phone.webrtc_enabled:
            return JsonResponse({
                'success': False,
                'error': 'WebRTC not enabled for this phone'
            })

        config = _build_webrtc_config(phone)
        return JsonResponse(config)

    except Exception as e:
        logger.error(f"Error getting WebRTC config: {e}")
        return JsonResponse({'success': False, 'error': 'Failed to get WebRTC configuration'})


@login_required
@agent_required
@require_http_methods(["GET"])
def agent_statistics(request):
    """Get agent statistics"""
    agent = request.user

    try:
        today = timezone.now().date()
        today_calls = CallLog.objects.filter(agent=agent, start_time__date=today)

        week_start = today - timedelta(days=today.weekday())
        week_calls = CallLog.objects.filter(agent=agent, start_time__date__gte=week_start)

        today_total = today_calls.count()
        today_answered = today_calls.filter(call_status='answered').count()
        today_talk_time = today_calls.aggregate(total=Sum('talk_duration'))['total'] or 0

        week_total = week_calls.count()
        week_answered = week_calls.filter(call_status='answered').count()
        week_talk_time = week_calls.aggregate(total=Sum('talk_duration'))['total'] or 0

        pending_callbacks = AgentCallbackTask.objects.filter(
            agent=agent, status__in=['pending', 'scheduled']
        ).count()

        return JsonResponse({
            'success': True,
            'today': {
                'total_calls': today_total,
                'answered_calls': today_answered,
                'talk_time': today_talk_time,
                'contact_rate': round(
                    (today_answered / today_total * 100) if today_total > 0 else 0, 1
                )
            },
            'week': {
                'total_calls': week_total,
                'answered_calls': week_answered,
                'talk_time': week_talk_time,
                'contact_rate': round(
                    (week_answered / week_total * 100) if week_total > 0 else 0, 1
                )
            },
            'pending_callbacks': pending_callbacks
        })

    except Exception as e:
        logger.error(f"Error getting agent statistics: {e}")
        return JsonResponse({'success': False, 'error': 'Failed to get statistics'})


@login_required
@agent_required
@require_http_methods(["GET"])
def agent_call_history(request):
    """Get agent call history (paginated)"""
    agent = request.user
    page = int(request.GET.get('page', 1))
    per_page = int(request.GET.get('per_page', 20))

    try:
        calls = CallLog.objects.filter(agent=agent).order_by('-start_time')
        total = calls.count()

        start = (page - 1) * per_page
        end = start + per_page
        calls_page = calls[start:end]

        return JsonResponse({
            'success': True,
            'total': total,
            'page': page,
            'per_page': per_page,
            'calls': [
                {
                    'id': c.id,
                    'number': c.called_number,
                    'status': c.call_status,
                    'disposition': c.disposition or '',
                    'duration': c.talk_duration or 0,
                    'date': c.start_time.strftime('%Y-%m-%d %H:%M'),
                    'lead_id': c.lead_id,
                }
                for c in calls_page
            ]
        })

    except Exception as e:
        logger.error(f"Error getting call history: {e}")
        return JsonResponse({'success': False, 'error': 'Failed to get call history'})
