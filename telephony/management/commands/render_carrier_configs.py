from pathlib import Path
from django.core.management.base import BaseCommand, CommandError
from django.utils import timezone
from django.utils.text import slugify
from telephony.models import Carrier


class Command(BaseCommand):
    help = (
        "Render active carriers into static Asterisk config files "
        "(/etc/asterisk/pjsip_custom.conf + extensions_custom.conf by default)."
    )

    def add_arguments(self, parser):
        parser.add_argument(
            "--pjsip-out",
            default="/etc/asterisk/pjsip_custom.conf",
            help="Destination file for generated PJSIP carrier sections.",
        )
        parser.add_argument(
            "--dialplan-out",
            default="/etc/asterisk/extensions_custom.conf",
            help="Destination file for generated outbound dialplan.",
        )
        parser.add_argument(
            "--context",
            default="from-campaign",
            help="Dialplan context name to populate with carrier prefixes.",
        )
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help="Print the generated snippets instead of writing files.",
        )

    def handle(self, *args, **options):
        carriers = list(
            Carrier.objects.filter(is_active=True, protocol__iexact="pjsip")
            .order_by("priority", "name")
            .select_related("asterisk_server")
        )

        if not carriers:
            raise CommandError("No active PJSIP carriers found.")

        render_items = [
            {
                "carrier": carrier,
                "section": self._section_name(carrier),
                "has_auth": bool(
                    (carrier.auth_username or carrier.username) and carrier.password
                ),
            }
            for carrier in carriers
        ]

        dialplan_items = [item for item in render_items if item["carrier"].dial_prefix]
        skipped = [
            item["carrier"].name for item in render_items if not item["carrier"].dial_prefix
        ]

        timestamp = timezone.now().strftime("%Y-%m-%d %H:%M:%S %Z")
        context_name = options["context"]
        pjsip_text = self._render_pjsip(render_items, timestamp, context_name)
        dialplan_text = self._render_dialplan(
            dialplan_items, timestamp, context_name=context_name
        )

        if options["dry_run"]:
            self.stdout.write("### PJSIP ###")
            self.stdout.write(pjsip_text)
            self.stdout.write("\n### Dialplan ###")
            self.stdout.write(dialplan_text)
            return

        pjsip_path = Path(options["pjsip_out"])
        dialplan_path = Path(options["dialplan_out"])

        self._write_file(pjsip_path, pjsip_text)
        self._write_file(dialplan_path, dialplan_text)

        message = (
            self.style.SUCCESS(
                f"Rendered {len(render_items)} carriers to "
                f"{pjsip_path} and {dialplan_path}. Reload Asterisk when ready."
            )
        )
        if skipped:
            message += "\n" + self.style.WARNING(
                "Dialplan blocks skipped for carriers without dial_prefix: "
                + ", ".join(skipped)
            )
        self.stdout.write(message)

    def _section_name(self, carrier):
        slug = slugify(carrier.name) or f"carrier-{carrier.pk}"
        slug = slug.replace("-", "_")
        return slug or f"carrier_{carrier.pk}"

    def _render_pjsip(self, items, timestamp, context_name):
        lines = [
            "; ---------------------------------------------------------------------",
            "; Autogenerated PJSIP carrier config",
            f"; Generated: {timestamp}",
            "; Command: manage.py render_carrier_configs",
            "; ---------------------------------------------------------------------",
            "",
        ]

        for item in items:
            carrier = item["carrier"]
            section = item["section"]
            allow = carrier.codec.replace(" ", "")
            username = carrier.auth_username or carrier.username
            has_auth = item["has_auth"]
            host = carrier.server_ip
            port = carrier.port or 5060
            contact_uri = f"sip:{host}:{port}"

            lines.append(f"; Carrier: {carrier.name} ({carrier.server_ip})")
            lines.append(f"[{section}]")
            lines.append("type=endpoint")
            lines.append("transport=transport-udp")
            lines.append(f"context={context_name}")
            lines.append("disallow=all")
            lines.append(f"allow={allow}")
            lines.append(f"outbound_auth={section}" if has_auth else "; outbound_auth disabled (IP auth)")
            lines.append(f"auth={section}" if has_auth else "; auth disabled (IP auth)")
            lines.append(f"aors={section}_aor")
            lines.append("rewrite_contact=yes")
            lines.append(f"dtmf_mode={carrier.dtmf_mode}")
            lines.append(f"rtp_symmetric={'yes' if carrier.nat else 'no'}")
            lines.append("force_rport=yes")
            lines.append("direct_media=no")
            if host:
                lines.append(f"from_domain={host}")
            lines.append("")

            lines.append(f"[{section}_aor]")
            lines.append("type=aor")
            lines.append("max_contacts=1")
            lines.append("remove_existing=yes")
            lines.append(f"qualify_frequency=60")
            if carrier.registration_type == "ip" and host:
                lines.append(f"contact={contact_uri}")
            else:
                lines.append(f"; registration-based carrier, contact learned via registration")
            lines.append("")

            if has_auth:
                lines.append(f"[{section}_auth]")
                lines.append("type=auth")
                lines.append("auth_type=userpass")
                lines.append(f"username={username}")
                lines.append(f"password={carrier.password}")
                lines.append("realm=asterisk")
                lines.append("")

            if carrier.registration_type == "registration" and has_auth:
                lines.append(f"[reg-{section}]")
                lines.append("type=registration")
                lines.append("transport=transport-udp")
                lines.append(f"outbound_auth={section}")
                lines.append(f"server_uri={contact_uri}")
                lines.append(f"client_uri=sip:{username}@{host}")
                lines.append("line=yes")
                lines.append(f"endpoint={section}")
                lines.append("retry_interval=60")
                lines.append("forbidden_retry_interval=600")
                lines.append("expiration=3600")
                lines.append("")

            if host:
                lines.append(f"[{section}-identify]")
                lines.append("type=identify")
                lines.append(f"endpoint={section}")
                lines.append(f"match={host}")
                lines.append("")

        return "\n".join(lines).strip() + "\n"

    def _render_dialplan(self, items, timestamp, context_name):
        lines = [
            "; ---------------------------------------------------------------------",
            "; Autogenerated outbound dialplan with AMD and Stasis support",
            f"; Generated: {timestamp}",
            "; Context: {context}".format(context=context_name),
            "; Command: manage.py render_carrier_configs",
            "; ---------------------------------------------------------------------",
            "",
            f"[{context_name}]",
            "",
            "; AMD and Stasis handler for predictive dialer",
            "exten => _X.,1,NoOp(Outbound Campaign Call to ${EXTEN})",
            " same => n,Set(CHANNEL(hangup_handler_push)=hangup-handler,s,1)",
            " same => n,Set(DIAL_TIMEOUT=${DIAL_TIMEOUT:-30})",
            "",
            "; Check if AMD is enabled",
            " same => n,GotoIf($[\"${AMD_ENABLED}\" = \"1\"]?find_carrier:dial_direct)",
            "",
            "; Find matching carrier by prefix",
            " same => n(find_carrier),NoOp(Selecting carrier)",
        ]

        # Group carriers by prefix so we can randomize within a prefix group.
        prefix_groups = {}
        prefix_order = []
        for idx, item in enumerate(items):
            carrier = item["carrier"]
            prefix = carrier.dial_prefix or ""
            if not prefix:
                continue
            if prefix not in prefix_groups:
                prefix_groups[prefix] = []
                prefix_order.append(prefix)
            prefix_groups[prefix].append(idx)

        # Add carrier-specific routing with random pick per prefix.
        for prefix in prefix_order:
            indexes = prefix_groups[prefix]
            label = "pick_prefix_" + "".join(
                ch if ch.isalnum() else "_" for ch in prefix
            )
            lines.append(
                f" same => n,GotoIf($[\"${{EXTEN:0:{len(prefix)}}}\" = \"{prefix}\"]?{label})"
            )
            if len(indexes) == 1:
                lines.append(f" same => n({label}),Goto(carrier_{indexes[0]})")
            else:
                lines.append(f" same => n({label}),Set(TRUNK=${{RAND(1,{len(indexes)})}})")
                for pos, idx in enumerate(indexes, start=1):
                    lines.append(
                        f" same => n,GotoIf($[\"${{TRUNK}}\" = \"{pos}\"]?carrier_{idx})"
                    )
                lines.append(f" same => n,Goto(carrier_{indexes[0]})")
        
        # Default carrier (first one or fallback)
        if items:
            lines.append(" same => n,Goto(carrier_0)")
        else:
            lines.append(" same => n,Hangup()")
        
        lines.append("")
        
        # Add carrier dial sections
        for idx, item in enumerate(items):
            carrier = item["carrier"]
            section = item["section"]
            prefix = carrier.dial_prefix or ""
            strip_len = len(prefix)
            dial_number = f"${{EXTEN:{strip_len}}}" if strip_len else "${EXTEN}"
            host = carrier.server_ip
            port = carrier.port or 5060
            dial_uri = f"${{OUTNUM}}@{host}:{port}" if host else "${OUTNUM}"
            dial_timeout = carrier.dial_timeout or 30
            
            lines.append(f"; Carrier {carrier.name} (priority {carrier.priority})")
            lines.append(f" same => n(carrier_{idx}),Set(OUTNUM={dial_number})")
            lines.append(
                " same => n,Set(EFFECTIVE_DIAL_TIMEOUT=${IF($[\"${DIAL_TIMEOUT}\"=\"\"]?"
                f"{dial_timeout}:$" + "{DIAL_TIMEOUT})})"
            )
            
            # Use U() option to run AMD/Stasis on the callee channel upon answer
            if host:
                # Pass campaign metadata into the AMD handler so Stasis gets CALL_TYPE/CAMPAIGN_ID/LEAD_ID/HOPPER_ID
                lines.append(
                    f" same => n,Dial(PJSIP/{section}/sip:${{OUTNUM}}@{host}:{port},${{EFFECTIVE_DIAL_TIMEOUT}},"
                    f"U(amd-handler^${{CALL_TYPE:-autodial}}^${{CAMPAIGN_ID}}^${{LEAD_ID}}^${{HOPPER_ID}}))"
                )
            else:
                lines.append(
                    f" same => n,Dial(PJSIP/{section}/${{OUTNUM}},${{EFFECTIVE_DIAL_TIMEOUT}},U(amd-handler))"
                )
            
            lines.append(" same => n,Goto(failed)")
            lines.append("")
        
        # Failure handler
        lines.extend([
            " same => n(failed),NoOp(Call failed: ${DIALSTATUS})",
            " same => n,Hangup()",
            "",
            "; Direct dial (no AMD)",
            " same => n(dial_direct),Goto(find_carrier)",
            "",
            "; Holding extension for Local channel",
            "exten => wait_for_call,1,Answer()",
            " same => n,Wait(7200)",
            " same => n,Hangup()",
            "",
        ])

        # AMD Handler Subroutine
        lines.extend([
            "[amd-handler]",
            "exten => s,1,NoOp(Call answered - checking AMD)",
            " same => n,Set(CALL_TYPE=${IF($[\"${ARG1}\"=\"\"]?${CALL_TYPE}:${ARG1})})",
            " same => n,Set(CAMPAIGN_ID=${IF($[\"${ARG2}\"=\"\"]?${CAMPAIGN_ID}:${ARG2})})",
            " same => n,Set(LEAD_ID=${IF($[\"${ARG3}\"=\"\"]?${LEAD_ID}:${ARG3})})",
            " same => n,Set(HOPPER_ID=${IF($[\"${ARG4}\"=\"\"]?${HOPPER_ID}:${ARG4})})",
            " same => n,GotoIf($[\"${AMD_ENABLED}\" = \"1\"]?run_amd:send_to_stasis)",
            "",
            "; Run AMD",
            " same => n(run_amd),AMD(${AMD_SILENCE:-2500},${AMD_AFTER_GREETING_SILENCE:-800},${AMD_TOTAL_ANALYSIS_TIME:-5000},${AMD_MIN_WORD_LENGTH:-100},${AMD_BETWEEN_WORDS_SILENCE:-50},${AMD_MAXIMUM_NUMBER_OF_WORDS:-3},${AMD_MAXIMUM_WORD_LENGTH:-5000})",
            " same => n,NoOp(AMD Result: ${AMDSTATUS} - ${AMDCAUSE})",
            " same => n,Set(AMD_STATUS=${AMDSTATUS})",
            " same => n,Set(AMD_CAUSE=${AMDCAUSE})",
            " same => n,GotoIf($[\"${AMDSTATUS}\" = \"MACHINE\"]?machine:send_to_stasis)",
            "",
            "; Machine detected - hangup",
            " same => n(machine),NoOp(Machine detected - hanging up)",
            " same => n,Hangup()",
            "",
            "; Human or no AMD - send to Stasis for agent routing",
            " same => n(send_to_stasis),Stasis(autodialer,${CALL_TYPE},${CAMPAIGN_ID},${LEAD_ID},${HOPPER_ID})",
            " same => n,Return()",
            "",
        ])
        
        # Hangup handler
        lines.extend([
            "[hangup-handler]",
            "exten => s,1,NoOp(Call ended)",
            " same => n,Return()",
            "",
        ])

        return "\n".join(lines).strip() + "\n"

    def _write_file(self, path: Path, contents: str):
        if not path.parent.exists():
            path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(contents)
